# Описание возможностей, по составлению запросов

## Поиск по полю

Поиск по полю - это то, как вы определяете содержание предложения SQL WHERE.

Поиск по полю происходит после знака ```__``` . Сначала пишите поле, затем применяете к нему метод через ```__```

При помощи ```__``` вы можете ```получать доступ к связанным полям``` и дальше уже работать с тем полем

Например необходимо вывести все записи блогов, где у автора в имени содержится 'writer'.

```python
obj = Entry.objects.filter(authors__name__contains='writer')
print(obj)
"""<QuerySet [<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Секреты успешного похудения>]>"""
```
Заметьте, как идёт подключение. Мы пытаемся из таблицы Entry через ```filter``` 
обратиться к полю ```authors``` (которое является связанное отношением многое-ко-многому 
(абсолютно так же делается с отношением
один-к-многому)), у ```authors``` содержатся ссылки на таблицу ```Author``` у
которой есть поле ```name```, поэтому мы подключаемся к ней через ```__``` (именно из-за этих соображений
не разрешено называть поле при формировании модели как ```__``` или название поля оканчиваться на ```_```) 

Но, через ```__``` можно и подключится к объектам, у которых нет прямой связи, но есть косвенная.
Допустим модель ```Author``` и ```AuthorProfile```. У ```AuthorProfile``` есть связь ```OneToOneField``` с
```Author```, но обратной связи мы не прописываем, а она есть. Можно идти как вперед,
так и назад.

Поэтому можно решить такую задачу, как вывод всех записей блогов, 
где у автора не указан город.

```python
obj = Entry.objects.filter(authors__authorprofile__city=None)
print(obj)
"""<QuerySet [<Entry: Знакомство с Парижем>, <Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Экзотические специи и их использование>, <Entry: Гастрономическое путешествие по Франции>, 
<Entry: Инновации в области виртуальной реальности>, <Entry: Тенденции моды на текущий сезон>]>"""
```
Однако для такого случая необходимо указывать таблицу где есть данное поле. 
В поле ```authors```
идёт ссылка на таблицу ```Author```, у которой нет явного поля ```city```, но есть
неявная связь с таблицей ```AuthorProfile``` по первичному ключу, поэтому мы этим пользуемся
и указываем связь ```authors__authorprofile```, ну а далее раз связь настроена, 
то подключаемся к полю ```city``` таблицы ```AuthorProfile```.

### exact, iexact
Точное совпадение c учетом и без учёта (работает не во всех БД) регистра соответственно.
```python
print(Entry.objects.get(id__exact=4))
print(Entry.objects.get(id=4))  # Аналогично exact
print(Blog.objects.get(name__iexact="Путешествия по миру"))
```
### contains, icontains
Чувствительный, нечувствительное к регистру поиск
```python
print(Entry.objects.filter(headline__contains='мод'))
# <QuerySet [
# <Entry: Тенденции моды на текущий сезон>, 
# <Entry: История моды: от ретро до современности>, 
# <Entry: Интервью с известными модельерами и дизайнерами>
# ]>
```
### in
Проверка вхождения
```python
print(Entry.objects.filter(id__in=[1, 3, 4]))
# <QuerySet [<Entry: Изучение красот Мачу-Пикчу>, <Entry: Знакомство с Парижем>, <Entry: Открывая тайны Колизея>]>

print(Entry.objects.filter(number_of_comments__in='123'))  # число комментариев 1 или 2 или 3
"""
<QuerySet [
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Открывая тайны Колизея>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Топ-10 фитнес-тренеров для вдохновения>, 
<Entry: История моды: от ретро до современности>
]>
"""
```
Вы также можете использовать набор запросов для динамической оценки списка значений 
вместо предоставления списка литеральных значений:
```python
inner_qs = Blog.objects.filter(name__contains='Путешествия')
entries = Entry.objects.filter(blog__in=inner_qs)
print(entries)
"""
<QuerySet [
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Приключения в Амазонке>, 
<Entry: Знакомство с Парижем>, 
<Entry: Открывая тайны Колизея>, 
<Entry: Оазисы Сахары: красота и опасность>
]>
"""
```
### gt, gte, lt, lte
Больше чем; Больше равно чем; Меньше чем; Меньше равно чем
```python
# Вывести все записи, у которых число комментарием больше 10
print(Entry.objects.filter(number_of_comments__gt=10))
"""
<QuerySet [
<Entry: Приключения в Амазонке>, 
<Entry: Новые гаджеты и устройства: обзор рынка>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>, 
<Entry: Инновации в области виртуальной реальности>
]>
"""
# Вывести все записи, которые опубликованы (поле pub_date) позже и равное 01.06.2023
import datetime
print(Entry.objects.filter(pub_date__gte=datetime.date(2023, 6, 1)))
"""
<QuerySet [
<Entry: Приготовление собственного хлеба>, 
<Entry: Десерты для настоящих сладкоежек>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Топ-10 фитнес-тренеров для вдохновения>, 
<Entry: Как правильно заниматься йогой>, 
<Entry: Последние тренды в мире искусственного интеллекта>, 
<Entry: Как создать стильный образ на каждый день>, 
<Entry: История моды: от ретро до современности>
]>
"""
# Вывести все записи, у которых число комментарием больше 10 и рейтинг < 4
print(Entry.objects.filter(number_of_comments__gt=10).filter(rating__lt=4))
"""
<QuerySet [
<Entry: Новые гаджеты и устройства: обзор рынка>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>
]>
"""
# Вывести все записи, у которых заголовок статьи лексиграфически <= "Зя"
print(Entry.objects.filter(headline__lte="Зя"))
"""
<QuerySet [
<Entry: Знакомство с Парижем>, 
<Entry: Десерты для настоящих сладкоежек>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Здоровое питание: полезные рецепты>
]>
"""
```
### startswith, istartswith, endswith, iendswith
Начинается с (с/без учетом регистра), заканчивается на (с/без учетом регистра).
```python
print(Entry.objects.filter(headline__startswith='Как'))
# <QuerySet [<Entry: Как правильно заниматься йогой>, <Entry: Как создать стильный образ на каждый день>]>
print(Entry.objects.filter(headline__endswith='ния'))
# <QuerySet [<Entry: Топ-10 фитнес-тренеров для вдохновения>, <Entry: Секреты успешного похудения>]>
```
### range
Диапазон проверки (включительно).
```python
# Вывести записи между 01.01.2023 и 31.12.2023
import datetime
start_date = datetime.date(2023, 1, 1)
end_date = datetime.date(2023, 12, 31)
print(Entry.objects.filter(pub_date__range=(start_date, end_date)))
"""
<QuerySet [
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Рецепты блюд из итальянской кухни>, 
<Entry: Приготовление собственного хлеба>, 
<Entry: Десерты для настоящих сладкоежек>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Здоровое питание: полезные рецепты>, 
<Entry: Секреты успешного похудения>, 
<Entry: История моды: от ретро до современности>, 
<Entry: Уход за кожей и волосами: лучшие советы>, 
<Entry: Интервью с известными модельерами и дизайнерами>
]>
"""
# При данной постановке задачи (вывод за конкретный год) будет проще воспользоваться __year результат будет аналогичен
print(Entry.objects.filter(pub_date__year=2023))
```
### year, month, day, week, week_day, quarter, hour, minute, second
Для полей даты и даты и времени точное совпадение:
* года(year)
* месяца(month)
* дня(day)
* недели(week)
* дня недели(week_day)
* квартала(quarter)
* часа(hour)
* минуты(minute)
* секунды(second).
Примеры
```python
# Вывести записи старше 2022 года
print(Entry.objects.filter(pub_date__year__lt=2022))
"""
<QuerySet [
<Entry: Новые гаджеты и устройства: обзор рынка>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>, 
<Entry: Инновации в области виртуальной реальности>
]>
"""
# Вывести все записи за февраль доступных годов, отобразить название, дату публикации, заголовок
print(Entry.objects.filter(pub_date__month=2).values('blog__name', 'pub_date', 'headline'))
"""
<QuerySet [
{'blog__name': 'ИТ-новости и технологии', 'pub_date': datetime.date(2022, 2, 1), 'headline': 'Развитие интернета вещей: будущее или реальность?'}, 
{'blog__name': 'Мода и стиль', 'pub_date': datetime.date(2023, 2, 1), 'headline': 'Уход за кожей и волосами: лучшие советы'}, 
{'blog__name': 'Мода и стиль', 'pub_date': datetime.date(2023, 2, 1), 'headline': 'Интервью с известными модельерами и дизайнерами'}
]>
"""
# Вывести username авторов у которых есть публикации с 1 по 15 апреля 2023 года, вывести без использования range. Пример для работы с __day
print(Entry.objects.filter(pub_date__year=2023).filter(pub_date__day__gte=1).filter(pub_date__day__lte=15).values_list("authors__name").distinct())
# Сначала отфильтровываем по году, затем по дням, затем получаем значения имен у авторов и говорим, чтобы не было повторов
"""
<QuerySet [
('vladimir_writer',), 
('andrey_author',), 
('nikolay_blog',), 
('roman_author',), 
('dmitriy_creative',), 
('alexander89',), 
('irina_blogger',), 
('ivan_wordsmith',), 
('maxim_writer',)
]>
"""
# Вывести статьи опубликованные в понедельник (так как datetime работает по американской системе,
# то начало недели идёт с воскресенья, а заканчивается субботой, поэтому понедельник второй день в неделе)
print(Entry.objects.filter(pub_date__week_day=2).values('blog__name', 'pub_date', 'headline'))
"""
<QuerySet [
{'blog__name': 'Путешествия по миру', 'pub_date': datetime.date(2022, 8, 1), 'headline': 'Приключения в Амазонке'}, 
{'blog__name': 'Фитнес и здоровый образ жизни', 'pub_date': datetime.date(2023, 5, 1), 'headline': 'Здоровое питание: полезные рецепты'}, 
{'blog__name': 'Фитнес и здоровый образ жизни', 'pub_date': datetime.date(2024, 1, 1), 'headline': 'Топ-10 фитнес-тренеров для вдохновения'}, 
{'blog__name': 'Фитнес и здоровый образ жизни', 'pub_date': datetime.date(2024, 4, 1), 'headline': 'Как правильно заниматься йогой'}, 
{'blog__name': 'ИТ-новости и технологии', 'pub_date': datetime.date(2024, 4, 1), 'headline': 'Последние тренды в мире искусственного интеллекта'}
]>
"""
# week, quarter, hour, minute, second рассматривается аналогично как и всё что было ранее
```
### date, time
Для полей даты и времени преобразует значение как дату или время. 

Нужно быть внимательным так как ```__date``` и ```__time``` не применить к полям типа DateField, только к DateTimeField
```python
import datetime
# Вывод всех записей по конкретной дате
print(Entry.objects.filter(pub_date__date=datetime.date(2021, 6, 1)))
# <QuerySet [<Entry: Новые гаджеты и устройства: обзор рынка>]>

# Вывод всех записей новее конкретной даты
print(Entry.objects.filter(pub_date__date__gt=datetime.date(2024, 1, 1)))
"""
<QuerySet [
<Entry: Как правильно заниматься йогой>, 
<Entry: Последние тренды в мире искусственного интеллекта>, 
<Entry: Как создать стильный образ на каждый день>
]>
"""

# Вывод записей по конкретному времени
print(Entry.objects.filter(pub_date__time=datetime.time(12, 00)))
"""
<QuerySet [
<Entry: Как создать стильный образ на каждый день>, 
<Entry: История моды: от ретро до современности>, 
<Entry: Уход за кожей и волосами: лучшие советы>, <Entry: Интервью с известными модельерами и дизайнерами>
]>
"""

# Вывод записей по временному диапазону с 6 утра до 17 вечера
print(Entry.objects.filter(pub_date__time__range=(datetime.time(6), datetime.time(17))))
"""
<QuerySet [
<Entry: Как правильно заниматься йогой>, 
<Entry: Секреты успешного похудения>, 
<Entry: Последние тренды в мире искусственного интеллекта>, 
<Entry: Развитие интернета вещей: будущее или реальность?>, 
<Entry: Новые гаджеты и устройства: обзор рынка>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>, 
<Entry: Инновации в области виртуальной реальности>, 
<Entry: Тенденции моды на текущий сезон>, 
<Entry: Как создать стильный образ на каждый день>, 
<Entry: История моды: от ретро до современности>, 
<Entry: Уход за кожей и волосами: лучшие советы>, 
<Entry: Интервью с известными модельерами и дизайнерами>]>
"""
```
### isnull
Принимает True или False, которые соответствуют SQL-запросам IS NULL и IS NOT NULL, соответственно
```python
# Вывести всех авторов которые не указали город
print(AuthorProfile.objects.filter(city__isnull=True))
"""
<QuerySet [
<AuthorProfile: anna_journey>, 
<AuthorProfile: natalia_author>, 
<AuthorProfile: vladimir_writer>, 
<AuthorProfile: alexandra_creative>, 
<AuthorProfile: svetlana_writer>, 
<AuthorProfile: larisa_thinker>
]>
"""
```
### regex, iregex
Чувствительное/нечувствительное к регистру совпадение регулярного выражения.
```python
# Вывести записи где в тексте статьи встречается патерн \w*стран\w*
print(Entry.objects.filter(body_text__regex=r'\w*стран\w*'))
"""
<QuerySet [
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>
]>
"""
# Вывести записи авторов с почтовыми доменами @gmail.com и @mail.ru
print(Entry.objects.filter(authors__email__iregex=r'\w+(@gmail.com|@mail.ru)'))
"""
<QuerySet [
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Знакомство с Парижем>, 
<Entry: Знакомство с Парижем>, 
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Приготовление собственного хлеба>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Как правильно заниматься йогой>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>, 
<Entry: Инновации в области виртуальной реальности>, 
<Entry: Тенденции моды на текущий сезон>, 
<Entry: Как создать стильный образ на каждый день>, 
<Entry: Уход за кожей и волосами: лучшие советы>, 
<Entry: Интервью с известными модельерами и дизайнерами>
]>
"""
# Если необходимо вывести записи авторов с почтовыми доменами @gmail.com и @mail.ru, но чтобы значения не повторялись, то используем distinct()
print(Entry.objects.filter(authors__email__iregex=r'\w+(@gmail.com|@mail.ru)').distinct())
"""
<QuerySet [
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Знакомство с Парижем>, 
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Приготовление собственного хлеба>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Как правильно заниматься йогой>, 
<Entry: Кибербезопасность: защита вашей конфиденциальности>, 
<Entry: Инновации в области виртуальной реальности>, 
<Entry: Тенденции моды на текущий сезон>, 
<Entry: Как создать стильный образ на каждый день>, 
<Entry: Уход за кожей и волосами: лучшие советы>, 
<Entry: Интервью с известными модельерами и дизайнерами>
]>
"""
```

## Применяемые методы для формирования запроса
### all()
Вывод всех значений в таблице ```objects.all()```
```python
all_obj = Blog.objects.all()
print("Вывод всех значений в таблице Blog\n", all_obj)
```

### first()
Вывод первого значения ```objects.first()```
```python
all_obj = Blog.objects.first()
print("Вывод первого значения в таблице Blog\n", all_obj)
```

### Последовательность запросов
Также можно вывести так, так как QuerySet не выполяются сразу и можно делать разные запросы
последовательно сужая область, при этом запросы останутся. QuerySet выполнится при обращении к нему: list, for, print,
получение объекта по индексу и т.д.
```python
all_obj = Blog.objects.all()
obj_first = all_obj.first()
print("Разные запросы на вывод в Blog\n", f"Первое значение таблицы = {obj_first}\n",
       f"Все значения = {all_obj}")
```

### Итерируемость
Объект QuerySet итерируемый, а значит есть возможность обращения через [] и слайсирование, for и т.д
```python
all_obj = Blog.objects.all()
for idx, value in enumerate(all_obj):
    print(f"idx = {idx}, value = {value}")
print(all_obj[0])  # Получение 0-го элемента
print(all_obj[2:4])  # Получение 2 и 3 элемента
"""Получение последнего элемента не осуществимо через обратный индекс
all_obj[-1] - нельзя
можно воспользоваться latest('<name_field>'), где <name_field> - имя колонки в БД.

Почти все операции над БД не требуют предварительного получения всех элементов, постоянная запись Blog.objects.all()
просто для примера.
"""
print(all_obj.latest("id"))  # Получение последнего элемента
print(Blog.objects.latest("id"))  # Одинаково работает
```

### get()
Для получения конкретного элемента необходимо использовать ```objects.get(**conditions)```, где ```**conditions``` - условия
их может быть не одно. get - возвращает только одно значение, если при ваших условиях возвращается не одно значение,
значит необходимо использовать что-то другое, допустим ```objects.filter(**conditions)```. В условиях вы передаёте что необходимо
вывести строки БД при таких значениях полей
```python
# Пример получения элемента по одному условию
print(Blog.objects.get(id=1))
# Пример получения элемента по двум условиям. Условия работают с оператором И, т.е. выведется строка, только с
# совпадением и первого и второго параметра.
print(Blog.objects.get(id=1, name="Путешествия по миру"))
# Если нет совпадений, то выйдет исключение "db.models.Blog.DoesNotExist: Blog matching query does not exist."
print(Blog.objects.get(id=2, name="Путешествия по миру"))
```

### filter()
Когда необходимо вывести более одного значения то можно использовать objects.filter(**conditions), **conditions
аналогично get(**conditions)
```python
print(Blog.objects.filter(id__gte=2))  # Вывод всех строк таблицы Blog у которых значение id >= 2. 
# Рассмотрение поиска по полям далее
```

### exclude()
Аналогично фильтру, только противоположность. Возвращает новый QuerySet, содержащий объекты, которые не соответствуют 
указанным параметрам поиска.
```python
print(Blog.objects.exclude(id__gte=2))  # Вывод всех строк таблицы Blog у которых значение id >= 2. 
# Рассмотрение поиска по полям далее
```

### exists()
Для проверки существования элемента(ов) в БД есть exists(), правда он применяется прямо к объекту, но только 
к объекту ```objects.filter(**conditions).exists()```

Для get придётся использовать блок try-except и ловить исключение ```MyModel.DoesNotExist```, где MyModel ваша модель
```python
# Пример для get
try:
    Blog.objects.get(id=2, name="Путешествия по миру")
except Blog.DoesNotExist:
    print("Не существует")
# Пример для filter
print(Blog.objects.filter(id=2, name="Путешествия по миру").exists())
```

### count()
Чтобы подсчитать количество записей в запросе существует метод count() который применяют к объекту запроса
```python
print(Blog.objects.count())  # Можно ко всей таблице
print(Blog.objects.filter(id__gte=2).count())  # Можно к запросу
all_data = Blog.objects.all()
filtred_data = all_data.filter(id__gte=2)
print(filtred_data.count())  # Можно к частным запросам
```

### order_by()
По умолчанию результаты, возвращаемые QuerySet, упорядочиваются с помощью кортежа, заданного параметром ordering в классе 
Meta модели. Вы можете переопределить это для каждого QuerySet, используя метод ```order_by```
```python
filtered_data = Blog.objects.filter(id__gte=2)
print(filtered_data.order_by("id"))  # упорядочивание по возрастанию по полю id
print(filtered_data.order_by("-id"))  # упорядочивание по уменьшению по полю id
print(filtered_data.order_by("-name", "id"))  # упорядочивание по двум параметрам, сначала по первому на уменьшение,
# затем второе на увеличение. Можно упорядочивание провести по сколь угодно параметрам.
```

### annotate()
Аннотирует каждый объект в QuerySet с помощью предоставленного списка выражений запроса. 
Выражение может быть простым значением, ссылкой на поле в модели (или любых связанных моделях) или агрегированным выражением 
(средние значения, суммы и т.д.), которое было вычислено для объектов, связанных с объектами в QuerySet.
```python
from django.db.models import Count
# Запрос, аннотирующий количество статей для каждого блога, 
# при этом добавляется новая колонка number_of_entries для вывода
entry = Blog.objects.annotate(number_of_entries=Count('entry')).values('name', 'number_of_entries')
print(entry)
"""
<QuerySet [
{'name': 'Путешествия по миру', 'number_of_entries': 5}, 
{'name': 'Кулинарные искушения', 'number_of_entries': 5}, 
{'name': 'Фитнес и здоровый образ жизни', 'number_of_entries': 5}, 
{'name': 'ИТ-новости и технологии', 'number_of_entries': 5}, 
{'name': 'Мода и стиль', 'number_of_entries': 5}
]>
"""
```

### alias()
То же, что ```annotate()```, но вместо аннотирования объектов в QuerySet сохраняет выражение для последующего повторного использования 
с другими методами QuerySet. Это полезно, когда результат самого выражения не нужен, но он используется для фильтрации, 
упорядочивания или как часть сложного выражения. 

Если не выбрать неиспользуемое значение, из базы данных удаляется избыточная работа, 
что должно привести к повышению производительности.

Таким образом, основная разница между ```annotate()``` и ```alias()``` заключается в том, что ```annotate()``` 
используется для добавления агрегированных значений к каждому объекту в QuerySet, тогда как ```alias()``` используется 
для создания псевдонимов для полей или связей в запросе, чтобы использовать их в других частях запроса.
```python
from django.db.models import Count
blogs = Blog.objects.alias(entries=Count('entry')).filter(entries__gt=4)
print(blogs)
"""
<QuerySet [
<Blog: Путешествия по миру>, 
<Blog: Кулинарные искушения>, 
<Blog: Фитнес и здоровый образ жизни>, 
<Blog: ИТ-новости и технологии>, 
<Blog: Мода и стиль>
]>
"""

## Выведет ошибку, так как поле entries не существует, виду различий между alias и annotate
# blogs = Blog.objects.alias(entries=Count('entry')).filter(entries__gt=4).values('blog', 'entries')
```

### aggregate()
Аргумент ```aggregate()``` описывает агрегированное значение, которое мы хотим вычислить
```aggregate()``` - это терминальное предложение для QuerySet, которое при вызове возвращает словарь пар имя-значение. 
Имя - это идентификатор совокупного значения; значение - это вычисленный агрегат. 
Имя автоматически генерируется из имени поля и агрегатной функции.

Если вы хотите вручную указать имя для агрегированного значения, вы можете сделать это, указав это имя при указании агрегатного предложения
Всего поддерживаются данные агрегационные функции:
* Avg
* Count
* Max, Min
* StdDev, Variance
* Sum

В общем случае функции могут принимать следующие параметры:

* ```expression``` (обязательный): Поле или выражение, для которого нужно вычислить 
среднее значение. Может быть именем поля модели или выражением, состоящим из полей, 
функций и операторов.
* ```output_field```: Опциональный параметр, позволяющий указать тип поля для вывода. 
По умолчанию output_field принимает значение FloatField(), чтобы вернуть среднее 
значение в виде числа с плавающей запятой. Однако вы можете указать другой тип поля, если требуется.
* ```distinct``` (логическое значение): Указывает, следует ли учитывать только 
уникальные значения при вычислении среднего значения. Если distinct=True, будут 
учтены только уникальные значения поля. По умолчанию distinct=False.
* ```filter``` (условие фильтрации): Позволяет задать условие фильтрации для агрегации. 
Только объекты, удовлетворяющие этому условию, будут учтены при вычислении среднего значения.
* ```default``` (значение по умолчанию): Устанавливает значение, которое будет 
возвращено, если агрегация не возвращает результат. Это может быть полезно, если 
вы хотите задать значение по умолчанию, если нет объектов для агрегации.

#### *Avg*
Возвращает среднее значение заданного выражения, которое должно быть числовым, 
если вы не укажете другое output_field

```class Avg(expression, output_field=None, distinct=False, filter=None, default=None, **extra)```

Пример
```python
from django.db.models import Avg, Q

# Вычислить среднюю оценку только для уникальных значений
average_rating = Entry.objects.aggregate(
    average_rating1=Avg('rating', distinct=True)
)
print(average_rating)  # {'average_rating1': 3.6999999999999993}

# Вычислить среднюю оценку с заданным значением по умолчанию(допустим
# значение у поля None), если агрегация не возвращает результат
average_rating_with_default = Entry.objects.aggregate(
    average_rating2=Avg('rating', default=5.0)
)
print(average_rating_with_default) # {'average_rating2': 3.46}

# Вычислить среднюю оценку только для статей, опубликованных после 2023 года
average_rating = Entry.objects.aggregate(
    average_rating3=Avg('rating', filter=Q(pub_date__year__gt=2023)))
print(average_rating) # {'average_rating3': 2.925}
```

#### *Count*

Возвращает количество объектов, связанных через предоставленное выражение.
```class Count(expression, distinct=False, filter=None, **extra)```

Пример
```python
 from django.db.models import Count

# Вычислить число уникальных авторов статей
average_rating = Entry.objects.aggregate(
    count_authors=Count('rating', distinct=True)
)
print(average_rating)  # {'count_authors': 16}

# Получить статьи с количеством авторов
entries_with_author_count = Entry.objects.annotate(
    author_count=Count('authors')).values('id', 'author_count')
print(entries_with_author_count)
"""
<QuerySet [
{'id': 1, 'author_count': 2}, 
{'id': 2, 'author_count': 1}, 
{'id': 3, 'author_count': 3}, 
{'id': 4, 'author_count': 2},
...
"""
```
#### *Max, Min*
Возвращает максимальное/минимальное значение данного выражения

```class Max(expression, output_field=None, filter=None, default=None, **extra)```

```class Min(expression, output_field=None, filter=None, default=None, **extra)```

Пример
```python
from django.db.models import Max, Min

# Вычислить максимальную и минимальную оценку
calc_rating = Entry.objects.aggregate(
    max_rating=Max('rating'), min_rating=Min('rating')
)
print(calc_rating)  # {'max_rating': 5.0, 'min_rating': 0.0}
```

#### *StdDev, Variance*
Возвращает стандартное отклонение данных в предоставленном выражении.

Возвращает дисперсию данных в предоставленном выражении

```class StdDev(expression, output_field=None, sample=False, filter=None, default=None, **extra)```

```class Variance(expression, output_field=None, sample=False, filter=None, default=None, **extra)```

Пример
```python
from django.db.models import StdDev, Variance

# Вычислить среднее квадратическое отклонение и дисперсию оценки
calc_rating = Entry.objects.aggregate(
    std_rating=StdDev('rating'), var_rating=Variance('rating')
)
print(calc_rating)  # {'std_rating': 1.6577092628081682, 'var_rating': 2.748}
```

#### *Sum*

Вычисляет сумму всех значений данного выражения

```class Sum(expression, output_field=None, distinct=False, filter=None, default=None, **extra)```

Пример
```python
from django.db.models import Sum

# Вычислить сумму комментариев в статьях
calc_rating = Entry.objects.aggregate(
    sum_comments=Sum('number_of_comments')
)
print(calc_rating)  # {'sum_comments': 134}
```

### reverse()
Изменение порядка вывода элемента из QuerySet. Если вам нужно просто изменить порядок элементов в наборе запросов 
на обратный без сортировки по конкретному полю, вы можете использовать метод ```reverse()```
```python
filtered_data = Blog.objects.filter(id__gte=2)
print(filtered_data.order_by("id"))  # упорядочивание по возрастанию по полю id
print(filtered_data.order_by("-id"))  # упорядочивание по уменьшению по полю id
print(filtered_data.order_by("-name", "id"))  # упорядочивание по двум параметрам, сначала по первому на уменьшение,
# затем второе на увеличение. Можно упорядочивание провести по сколь угодно параметрам.
```

### distinct()
Возвращает новый QuerySet, который использует SELECT DISTINCT в своем SQL-запросе. 
Это исключает повторяющиеся строки из результатов запроса. 

Если вы используете серверную часть базы данных, отличную от PostgreSQL, например MySQL или SQLite, вы столкнетесь 
ошибкой, поскольку эти системы баз данных не поддерживают предложение DISTINCT ON.
```python
print(Entry.objects.order_by('authors', 'pub_date').distinct('authors', 'pub_date'))  # Не работает в SQLite
# distinct('authors', 'pub_date') - оставляет уникальные строки по колонкам authors, pub_date
# distinct() - старается оставить уникальные данные по всем колонкам
# Аналогично с поиском по полю можно обращаться к связанным данным distinct('authors__name', 'pub_date')
```

### values()
Возвращает QuerySet, который возвращает словари, а не экземпляры модели, когда используется как итеративный.

Каждый из этих словарей представляет объект с ключами, соответствующими именам атрибутов объектов модели.

В этом примере сравниваются словари values() с объектами нормальной модели:
```python
# Обычный запрос
print(Blog.objects.filter(name__startswith='Фитнес'))
# <QuerySet [<Blog: Фитнес и здоровый образ жизни>]>

# Запрос раскрывающий значения
print(Blog.objects.filter(name__startswith='Фитнес').values())
"""
QuerySet [{'id': 3, 'name': 'Фитнес и здоровый образ жизни', 
'tagline': 'Позаботьтесь о своем здоровье, достигните физической формы и ощутите преимущества активного образа жизни!'}]>
"""

# Вывод всех строк с их раскрытием
print(Blog.objects.values())
"""
<QuerySet [
{'id': 1, 'name': 'Путешествия по миру', 'tagline': 'Откройте новые горизонты и погрузитесь в удивительные приключения вместе с нами!'}, 
{'id': 2, 'name': 'Кулинарные искушения', 'tagline': 'Раскройте вкусовые грани и наслаждайтесь миром кулинарии вместе с нами!'}, 
{'id': 3, 'name': 'Фитнес и здоровый образ жизни', 'tagline': 'Позаботьтесь о своем здоровье, достигните физической формы и ощутите преимущества активного образа жизни!'}, 
{'id': 4, 'name': 'ИТ-новости и технологии', 'tagline': 'Будьте в курсе последних новостей, трендов и инноваций в мире информационных технологий!'}, 
{'id': 5, 'name': 'Мода и стиль', 'tagline': 'Выражайте свою индивидуальность, следите за модными тенденциями и создавайте неповторимые образы вместе с нами!'}
]>
"""
# Вывод всех строк с сохранением в запросе только необходимых столбцов
print(Blog.objects.values('id', 'name'))  # Обратите внимание, что данные отсортированы по полю name
"""
<QuerySet [
{'id': 4, 'name': 'ИТ-новости и технологии'}, 
{'id': 2, 'name': 'Кулинарные искушения'}, 
{'id': 5, 'name': 'Мода и стиль'}, 
{'id': 1, 'name': 'Путешествия по миру'}, 
{'id': 3, 'name': 'Фитнес и здоровый образ жизни'}]>
"""
```

### values_list()
Это похоже на ```values()```, за исключением того, что вместо возврата словарей он 
возвращает кортежи при повторении. Каждый кортеж содержит значение из 
соответствующего поля или выражения, переданное в вызов ```values_list()``` - поэтому 
первый элемент является первым полем и т.д. Например:
```python
# Вывод всех строк с их раскрытием
print(Blog.objects.values_list())
"""
<QuerySet [
(1, 'Путешествия по миру', 'Откройте новые горизонты и погрузитесь в удивительные приключения вместе с нами!'), 
(2, 'Кулинарные искушения', 'Раскройте вкусовые грани и наслаждайтесь миром кулинарии вместе с нами!'), 
(3, 'Фитнес и здоровый образ жизни', 'Позаботьтесь о своем здоровье, достигните физической формы и ощутите преимущества активного образа жизни!'), 
(4, 'ИТ-новости и технологии', 'Будьте в курсе последних новостей, трендов и инноваций в мире информационных технологий!'), 
(5, 'Мода и стиль', 'Выражайте свою индивидуальность, следите за модными тенденциями и создавайте неповторимые образы вместе с нами!')
]>
"""
# Вывод всех строк с сохранением в запросе только необходимых столбцов
print(Blog.objects.values_list('id', 'name'))  # Обратите внимание, что данные отсортированы по полю name
"""
<QuerySet [
(4, 'ИТ-новости и технологии'), 
(2, 'Кулинарные искушения'), 
(5, 'Мода и стиль'), 
(1, 'Путешествия по миру'), 
(3, 'Фитнес и здоровый образ жизни')
]>
"""
```

### union(), intersection(), difference()
```union()``` использует оператор SQL UNION для объединения результатов двух или более QuerySet’ов

Применение оператора ```union()``` к нескольким QuerySets в данном формате позволяет выполнять операцию объединения в цепочке, 
добавляя все нужные QuerySets в порядке их объединения.
```python
qs1.union(qs2, qs3)
# или так
qs1.union(qs2).union(qs3)
```
Пример
```python
"""
Допустим, у нас есть три конкретных блога. Мы хотим получить объединение записей из этих трех блогов в один QuerySet.
"""
blog_a_entries = Entry.objects.filter(blog__name='Путешествия по миру')
blog_b_entries = Entry.objects.filter(blog__name='Кулинарные искушения')
blog_c_entries = Entry.objects.filter(blog__name='Фитнес и здоровый образ жизни')
result_qs = blog_a_entries.union(blog_b_entries, blog_c_entries)
print(result_qs)
"""
<QuerySet [
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Приключения в Амазонке>, 
<Entry: Знакомство с Парижем>, 
<Entry: Открывая тайны Колизея>, 
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Рецепты блюд из итальянской кухни>, 
<Entry: Приготовление собственного хлеба>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Десерты для настоящих сладкоежек>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Здоровое питание: полезные рецепты>, 
<Entry: Топ-10 фитнес-тренеров для вдохновения>, 
<Entry: Как правильно заниматься йогой>, 
<Entry: Секреты успешного похудения>
]>
"""
# Для такой задачи может хорошо подойти in (ответ будет аналогичен), правда порядок может быть другой
print(Entry.objects.filter(blog__name__in=['Путешествия по миру', 'Кулинарные искушения', 'Фитнес и здоровый образ жизни']))
"""
<QuerySet [
<Entry: Рецепты блюд из итальянской кухни>, 
<Entry: Приготовление собственного хлеба>, 
<Entry: Экзотические специи и их использование>, 
<Entry: Десерты для настоящих сладкоежек>, 
<Entry: Гастрономическое путешествие по Франции>, 
<Entry: Изучение красот Мачу-Пикчу>, 
<Entry: Приключения в Амазонке>, 
<Entry: Знакомство с Парижем>, 
<Entry: Открывая тайны Колизея>, 
<Entry: Оазисы Сахары: красота и опасность>, 
<Entry: Упражнения для поддержания физической формы>, 
<Entry: Здоровое питание: полезные рецепты>, 
<Entry: Топ-10 фитнес-тренеров для вдохновения>, 
<Entry: Как правильно заниматься йогой>, 
<Entry: Секреты успешного похудения>
]>
"""
```
```intersection()``` использует оператор SQL INTERSECT для возврата общих элементов двух или более QuerySet’ов.

Применение оператора ```intersection()``` к нескольким QuerySets позволяет найти пересечение записей между ними.  Например:
```python
qs1.intersection(qs2, qs3)
qs1.intersection(qs2).intersection(qs3)
```
Пример
```python
"""
Допустим, у нас есть три конкретных блога. Мы хотим получить авторов, которые написали статью во всех из перечисленных блогах.
"""
blog_a_entries = Entry.objects.filter(blog__name='Путешествия по миру').values('authors')
blog_b_entries = Entry.objects.filter(blog__name='Кулинарные искушения').values('authors')
blog_c_entries = Entry.objects.filter(blog__name='Фитнес и здоровый образ жизни').values('authors')
result_qs = blog_a_entries.intersection(blog_b_entries, blog_c_entries)
print(result_qs)
# <QuerySet [{'authors': 1}, {'authors': 9}, {'authors': 20}]>
```
```difference()``` использует оператор SQL EXCEPT для хранения только элементов, присутствующих в QuerySet, 
но не в каких-либо других QuerySet’ах. Например:
```python
qs1.difference(qs2, qs3)
qs1.difference(qs2).difference(qs3)
```
Пример
```python
"""
Вывести авторов, которые не написали ни одной статьи, в приведенных блогах
"""
blog_a_entries = Entry.objects.filter(blog__name='Путешествия по миру').values('authors')
blog_b_entries = Entry.objects.filter(blog__name='Кулинарные искушения').values('authors')
blog_c_entries = Entry.objects.filter(blog__name='Фитнес и здоровый образ жизни').values('authors')
result_qs = Entry.objects.values('authors').difference(blog_a_entries, blog_b_entries, blog_c_entries)
print(result_qs)
# <QuerySet [{'authors': 5}, {'authors': 7}, {'authors': 8}]>

# А допустим так (один из возможных запросов) можно узнать кто вообще не написал ни одной статьи в любой блог, 
# так как нет записей у этого автора в таблице Entry в поле authors
print(Author.objects.filter(entry__authors=None))
```

### select_related()
Возвращает QuerySet, который будет «следовать» отношениям внешнего ключа, выбирая 
дополнительные данные связанного объекта при выполнении своего запроса. Это повышение 
производительности, которое приводит к одному более сложному запросу, но означает, 
что дальнейшее использование отношений внешнего ключа не потребует запросов к базе данных.

Следующие примеры иллюстрируют разницу между простыми поисками и с использованием select_related(). 
Вот стандартный поиск:
```python
# Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
```
```python
# Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
```
Вы можете ссылаться на любое отношение ForeignKey или OneToOneField в списке полей, 
передаваемых в select_related().

### prefetch_related()
Возвращает ```QuerySet```, который автоматически извлекает в одном пакете связанные 
объекты для каждого из указанных поисков.

```prefetch_related``` имеет цель, аналогичную ```select_related```, в том смысле, что оба предназначены 
для урезания количества запросов к базе данных, вызванного доступом к связанным объектам, 
но стратегия совершенно иная.

```select_related``` работает путем создания соединения (join) SQL и включения полей 
связанного объекта в оператор SELECT. По этой причине ```select_related``` 
получает связанные объекты в одном запросе к базе данных. Тем не менее, чтобы 
избежать гораздо большего результирующего набора, который мог бы возникнуть в 
результате объединения через отношение „many“, ```select_related``` ограничен 
однозначными отношениями - внешним ключом и один-к-одному.

Например, предположим, у вас есть эти модели:

```python
from django.db import models

class Topping(models.Model):
    name = models.CharField(max_length=30)

class Pizza(models.Model):
    name = models.CharField(max_length=50)
    toppings = models.ManyToManyField(Topping)

    def __str__(self):
        return "%s (%s)" % (
            self.name,
            ", ".join(topping.name for topping in self.toppings.all()),
        )
    
>>> Pizza.objects.all()
["Hawaiian (ham, pineapple)", "Seafood (prawns, smoked salmon)"...
```
Проблема в том, что каждый раз, когда Pizza.str() запрашивает self.toppings.all(), он должен запросить базу данных, поэтому Pizza.objects.all() выполнит запрос к таблице Toppings для каждого элемента в Pizza QuerySet.

Мы можем сократить до двух запросов, используя ```prefetch_related```:
```python
Pizza.objects.prefetch_related('toppings')
```

## Дополнительный функционал позволяющий создавать сложные запросы

### F выражения

### Q объекты

### ExpressionWrapper()

### Case

### When

### With

### Subquery()

### Необработанные выражения SQL

### Функции окна