# Описание возможностей, по составлению запросов

## Получение элементов
### all()
Вывод всех значений в таблице ```objects.all()```

```python
all_obj = Blog.objects.all()
print("Вывод всех значений в таблице Blog\n", all_obj)
```
### first()
Вывод первого значения ```objects.first()```
```python
all_obj = Blog.objects.first()
print("Вывод первого значения в таблице Blog\n", all_obj)
```
### Последовательность запросов
Также можно вывести так, так как QuerySet не выполяются сразу и можно делать разные запросы
последовательно сужая область, при этом запросы останутся. QuerySet выполнится при обращении к нему: list, for, print,
получение объекта по индексу и т.д.
```python
all_obj = Blog.objects.all()
obj_first = all_obj.first()
print("Разные запросы на вывод в Blog\n", f"Первое значение таблицы = {obj_first}\n",
       f"Все значения = {all_obj}")
```
### Итерируемость
Объект QuerySet итерируемый, а значит есть возможность обращения через [] и слайсирование, for и т.д
```python
all_obj = Blog.objects.all()
for idx, value in enumerate(all_obj):
    print(f"idx = {idx}, value = {value}")
print(all_obj[0])  # Получение 0-го элемента
print(all_obj[2:4])  # Получение 2 и 3 элемента
"""Получение последнего элемента не осуществимо через обратный индекс
all_obj[-1] - нельзя
можно воспользоваться latest('<name_field>'), где <name_field> - имя колонки в БД.

Почти все операции над БД не требуют предварительного получения всех элементов, постоянная запись Blog.objects.all()
просто для примера.
"""
print(all_obj.latest("id"))  # Получение последнего элемента
print(Blog.objects.latest("id"))  # Одинаково работает
```
### get()
Для получения конкретного элемента необходимо использовать ```objects.get(**conditions)```, где ```**conditions``` - условия
их может быть не одно. get - возвращает только одно значение, если при ваших условиях возвращается не одно значение,
значит необходимо использовать что-то другое, допустим ```objects.filter(**conditions)```. В условиях вы передаёте что необходимо
вывести строки БД при таких значениях полей
```python
# Пример получения элемента по одному условию
print(Blog.objects.get(id=1))
# Пример получения элемента по двум условиям. Условия работают с оператором И, т.е. выведется строка, только с
# совпадением и первого и второго параметра.
print(Blog.objects.get(id=1, name="Путешествия по миру"))
# Если нет совпадений, то выйдет исключение "db.models.Blog.DoesNotExist: Blog matching query does not exist."
print(Blog.objects.get(id=2, name="Путешествия по миру"))
```

### filter()
Когда необходимо вывести более одного значения то можно использовать objects.filter(**conditions), **conditions
аналогично get(**conditions)
```python
print(Blog.objects.filter(id__gte=2))  # Вывод всех строк таблицы Blog у которых значение id >= 2. 
# Рассмотрение поиска по полям далее
```

### exclude()
Аналогично фильтру, только противоположность. Возвращает новый QuerySet, содержащий объекты, которые не соответствуют 
указанным параметрам поиска.
```python
print(Blog.objects.exclude(id__gte=2))  # Вывод всех строк таблицы Blog у которых значение id >= 2. 
# Рассмотрение поиска по полям далее
```

### exists()
Для проверки существования элемента(ов) в БД есть exists(), правда он применяется прямо к объекту, но только 
к объекту ```objects.filter(**conditions).exists()```
Для get придётся использовать блок try-except и ловить исключение ```MyModel.DoesNotExist```, где MyModel ваша модель
```python
# Пример для get
try:
    Blog.objects.get(id=2, name="Путешествия по миру")
except Blog.DoesNotExist:
    print("Не существует")
# Пример для filter
print(Blog.objects.filter(id=2, name="Путешествия по миру").exists())
```

### count()
Чтобы подсчитать количество записей в запросе существует метод count() который применяют к объекту запроса
```python
print(Blog.objects.count())  # Можно ко всей таблице
print(Blog.objects.filter(id__gte=2).count())  # Можно к запросу
all_data = Blog.objects.all()
filtred_data = all_data.filter(id__gte=2)
print(filtred_data.count())  # Можно к частным запросам
```
### order_by()
По умолчанию результаты, возвращаемые QuerySet, упорядочиваются с помощью кортежа, заданного параметром ordering в классе 
Meta модели. Вы можете переопределить это для каждого QuerySet, используя метод ```order_by```

```python
filtered_data = Blog.objects.filter(id__gte=2)
print(filtered_data.order_by("id"))  # упорядочивание по возрастанию по полю id
print(filtered_data.order_by("-id"))  # упорядочивание по уменьшению по полю id
print(filtered_data.order_by("-name", "id"))  # упорядочивание по двум параметрам, сначала по первому на уменьшение,
# затем второе на увеличение. Можно упорядочивание провести по сколь угодно параметрам.
```
### reverse()
Изменение порядка вывода элемента из QuerySet. Если вам нужно просто изменить порядок элементов в наборе запросов 
на обратный без сортировки по конкретному полю, вы можете использовать метод ```reverse()```
```python
filtered_data = Blog.objects.filter(id__gte=2)
print(filtered_data.order_by("id"))  # упорядочивание по возрастанию по полю id
print(filtered_data.order_by("-id"))  # упорядочивание по уменьшению по полю id
print(filtered_data.order_by("-name", "id"))  # упорядочивание по двум параметрам, сначала по первому на уменьшение,
# затем второе на увеличение. Можно упорядочивание провести по сколь угодно параметрам.
```